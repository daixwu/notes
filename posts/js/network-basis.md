
# 网络基础和应用

## 网络基础相关

### HTTP 响应常见状态码

HTTP 响应常见状态码这里只做一个速查总结。

- 100-199：表示成功接收请求, 要求客户端继续提交下一次请求才能完成整个处理过程，常见的有 101（客户要求服务器转换 HTTP 协议版本）、100（客户必须继续发出请求）

- 200-299：表示成功接收请求并已完成整个处理过程

- 300-399：需要客户进一步细化需求，以进一步完成请求，常用的有 301（永久重定向）、302（临时重定向）、304（缓存相关）

- 400-499：请求出错，包含语法错误或者无法正确执行逻辑，常用的有 404（无对应资源）、401（权限问题）、403 （服务器拒绝请求）

- 500-599：服务器端程序处理出现错误，常见的有 502（错误网关）、504（网关超时）、505（HTTP 版本不受支持）

### HTTP 请求方法

常见的 HTTP 请求方法有以下几个。

- GET 方法：该方法发送请求来取得服务器上的资源，一般来说 GET 方法应该只用于数据的读取，而不应当用于会产生副作用的非幂等的操作中。

- POST 方法：该方法向将指定资源的最新数据传送给服务器取代指定的资源的内容，POST 方法是非幂等的方法，因为这个请求可能会创建新的资源或 / 和修改现有资源。

- PUT 方法：类似 POST 方法，该方法指定了资源在服务器上的位置，进行数据提交或数据更新

- PATCH 方法：该方法出现的较晚，它在 2010 年的 RFC 5789 标准中被定义。一般用于资源的部分更新，而 PUT 一般用于资源的整体更新。另外，当资源不存在时，PATCH 会创建一个新的资源，而 PUT 只会对已在资源进行更新。

- DELETE 方法：该方法删除服务器上的某资源或者数据。

我们再从 HTTP 方法的安全性和幂等性角度来进行总结：

安全性是说多次调用不会产生副作用，换句话说，安全的方法不会修改资源状态；

幂等性，是指该方法多次调用返回的效果（形式）一致，客户端可以重复调用并且期望同样的结果。

| 方法名 | 安全性 | 幂等性 |
| -- | -- | -- |
| GET | 是 | 是 |
| POST | 否 | 否 |
| PUT | 否 | 是 |
| DELETE | 否 | 是 |

### 如何理解 HTTP 协议是无状态的

我们之所以说 HTTP 协议是无状态的，其实指的是客户端和服务器的通信，每个请求之间是独立的，指的是 HTTP 协议对于独立的请求是没有记忆能力的。

通俗点说，我们的应用发送一个请求，和下一次再打开该应用，发送同一个请求，这些请求之间没有任何联系。HTTP 是一个无状态的面向连接的协议，但是无状态不代表 HTTP 不能保持 TCP 连接，更不能代表 TCP 不是面向连接的。

### 跨域

跨域其实是浏览器的行为，狭义上说，它指的是浏览器无法执行其他网站的脚本。为什么无法执行呢？这要由浏览器的同源策略说起，简单来说，跨域是浏览器对 JavaScript 施加的安全限制。

所谓同源，是指「协议、域名、端口」这三要素都相同，在非同源的情况下，以下行为会受到限制：

- 对 Cookie、LocalStorage 和 IndexDB 的读取

- 对 DOM 和 JS 对象的读取

- Ajax 请求的正常执行

加载图片 CSS  js可无视同源策略：

- `<img src=跨域的图片地址/ >`  可用于统计打点，可使用第三方统计服务

- `<link href=跨域的css地址/>` 可使用CDN，CDN 一般都是外域

- `<script src=跨域的js地址></script>` 可使用 CDN，可实现 JSONP

### 代理和网关

代理简单来说，是一种有转发功能的应用程序，它扮演了位于两端之间「中间人」的角色。

网关是转发其他服务器通信数据的服务器，当接收从客户端发送来的请求时，它就像自己拥有资源的源服务器一样对请求进行处理，其工作机制和代理类似，但网关能力可能更加强大，它不是提供一个单一服务，而是能给通信链路提供平台化的服务，比如鉴权等内容。

### URI VS URL

很多开发者并不理解 URI 和 URL 的区别，从名称上来看：

- URL，统一资源定位符

- URI，统一资源标识符

通俗来说，URL 像是一个邮政编码，URI 就是收件地址。因此可知，URL 的范围大于 URI。我们以淘宝的例子来说，https://www.taobao.com/ 这个域名就是 URL，而每个商品的地址就是一个 URI。

很多 Ajax 请求库的参数都设计成叫做 url，表示请求地址。但实际上，更准确的表达是 URI。

## 网络应用相关

### 短网址功能实现

简单来说，短网址工具可以将一长串 URL 地址转换成简短的、可访问的短链接形式。那么一个短网址生成平台该怎么设计呢？其实原理很简单：

- 用户输入完整网址，服务端接收到完整网址之后，根据算法生成一个短码，维护完整网址和短码的映射关系，并将短码完善成短网址，返回给客户端；

- 任意客户端访问短网址，服务端根据完整网址和短码的映射关系，重定向到对应的页面。

我们看到了熟悉的三个字：重定向，请读者思考这里的重定向应该对应哪个 HTTP 状态码呢？

我们应该在 302 和 301 中进行选择：从语义上看，短网址对应完整网址的映射关系和跳转关系不会发生变化，应该是 301 永久重定向才对。但是更多的短网址生成平台却采用了 302，这是为什么呢？

如果用了 301，Google、百度等搜索引擎，搜索的时候会直接展示真实地址，那我们就无法统计到短地址被点击的次数了，也无法收集用户的 Cookie、User Agent 等信息，这些信息可以用来做很多有意思的大数据分析，也是短网址服务商的主要盈利来源。

完整的设计我们可以借助 MySQL 和 Redis 实现完整网址和短码之间的映射关系。生成短码的算法主要可以考虑以下几种：

- 自增 id，然后将 id 值转换为 62 进制的字符串，为了解决短码长度不固定的问题，可以指定数字开始递增。同时为了解决短码有序的安全隐患，可以结合 md5 进行混淆。一种实现为：

```js
const string10to62 = number => {
  const chars = '0123456789abcdefghigklmnopqrstuvwxyzABCDEFGHIGKLMNOPQRSTUVWXYZ'

  const charsArr = chars.split('')
  const radix = chars.length
  let qutient = +number
  let arr = []

  do {
    let mod = qutient % radix
    qutient = (qutient - mod) / radix
    arr.unshift(charsArr[mod])
  }
  while(qutient)

  return arr.join('')
}
```

- 哈希算法，直接输入任意长度的数据，输出固定长度的数据，这种算法比较典型，不再过多介绍

- 随机数：从 62 个字符串中随机取出固定长度的短码组合，然后去数据库中查询该短码是否已存在。如果已存在，就继续循环该方法重新获取短码，否则就直接返回。这种方法最为简单，但是得到碰撞的概率相对较大，一种实现为：

```js
const generateShortLink = () => {
  let str = ''
  const arr = [
    '0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
    'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z',
    'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
  ]

  for (let i = 0; i < 6; i++) {
    const pos = Math.round(Math.random() * (arr.length - 1))
    str += arr[pos]
  }
  return str
}

async getShortLink() {
  const shortLink = this.generateShortLink()

  const searchResult = await this.searchByLinkInMySQL(shortLink)

  if (searchResult && searchResult.length > 0) {
    return this.getShortLink();
  }
  return shortLink
}
```

### 扫码登录实现

现在授权第三方的扫码登录越来越流行。比如我们可以通过微信实现在第三方应用的登录、注册账号等，这种共用账号体系的能力究竟是如何实现的呢？

其实原理同样并不复杂：

- 首先打开 PC 端页面，PC 端页面生成一个二维码，这个二维码带有服务端下发的一个唯一 id：uuid

- 接着，手机在微信账号中进行扫码，发送请求，请求包含了上面提到的 uuid 和当前用户的账号信息

- 与此同时，PC 端不断轮询服务器（或者通过 websocket，服务端主动 push 信息），获取扫码登录的状态

- 服务端返回扫码状态

针对手机扫码后服务端的返回情况，我们进行梳理：

- PC 端在轮询时，如果扫码超时（手机没有授权登录或者就没扫码），服务端会阻塞一个时限（比如 30s），30s 内无响应，服务端返回状态码 408，得到返回后，前端继续轮询

- 大约 5 分钟内仍然没有扫码响应，则二维码失效，这时候服务端返回 400

- 如果手机端扫码成功，服务端返回 201 同时并返回用户信息，并等待用户点击「确认授权登录」

- 用户「确认授权登录」之后，服务端返回 200 同时返回一个 token；PC 端在拿到下响应后，重定向到目标页面，同时停止轮询

关键理解点：

- 扫码登录一共涉及到三端：服务端、PC 端和手机扫码端

- PC 端通过轮询，不断向服务端获取用户扫码登录的状态

- 服务端阻塞 PC 端请求，这样可以减少 PC 端轮询的次数，优化轮询过程

- 服务端根据手机扫码状态，返回 408、400、201、200 等状态码

### 断点续传原理

对于大文件的传输/下载，我们常常采用断点续传原理。想象一下在使用迅雷、网盘上传文件内容时，如果网络条件出现问题，我们仍然可以稍后继续进行上传/下载而不至于丢失之前的上传/下载进度。这种断点续传的能力究竟是如何实现的呢？

实现断点续传，需要依靠 HTTP1.1 协议（RFC2616），该协议版本开始支持获取文件的部分内容，这为并行下载以及断点续传提供了技术支持。

在前端发送请求时，需要在 Header 里加入 Range 参数，同时服务器端响应时返回带有 Content-Range 的 Header，也就是说 Range 和 Content-Range 是一对对应的 Header 头。

比如：

Range: bytes=500-999

就表示上传第 500-999 字节范围的内容，而浏览器在发出带 Range 的请求后，服务器会在 Content-Range 头部返回当前接受的范围和文件总大小，比如：

Content-Range: bytes 0-499/22400

就指当前发送数据的范围是 0-499，22400 则是文件的总 size。

我们来看一个例子：

- 浏览器下载一个 1024K 的文件，当前已经下载了 512K

- 这时候不幸网络故障，稍后浏览器请求续传，这时候带有 Range:bytes=512000 的 Header 头，表明本次需要续传的片段

- 服务端接收到断点续传的请求，从文件的 512K 位置开始传输，并返回 Header 头： Content-Range:bytes 512000-/1024000，注意这时候的 HTTP status code 是 206，而非 200，206 表示：206 Partial Content（使用断点续传方式）

请读者思考一个问题，如果在网络故障期间，服务器端文件发生了变化，导致 512K 部分并不能对上之前的内容，这个怎么办呢？

这时候就需要一个标识文件唯一性的标识符。RFC2616 中规定可以使用 Last-Modified 顾名思义，这样就可以标识文件的最后修改时间，浏览器就可判断出续传文件时是否已经发生过改动。这种方式并不惟一，也可以通过名为 Etag 的 Header，直接表文件的唯一标记（类似文件的 MD5 值）。浏览器端请求时申明 If-None-Match 或者 If-Modified-Since 字段，帮助服务端判别文件变化，同时浏览器也可以采用 If-Range Header，该头部包含 ETag 头或者是 Last-Modfied 信息，同样可以帮助服务端进行内容校验。这时候，服务端在校验一致时返回 206 的续传回应校验不通过时，服务端则返回 200 回应，回应的内容为新的文件的全部数据。
